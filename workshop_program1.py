# -*- coding: utf-8 -*-
"""workshop_program1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11RZ2cxqPdKDOq3NOTYtJ_gexFL-kbeBg

# **INTRODUCTION TO NUMPY**

---
Numpy is an extremely Populer Python  Module ,Heavily used in Scientific Computing
## Array


*   fast to operate as compared to list
*   convenient to use
*   consumes less memory
*   subscripted variable--A variable which can take an array of values is referred to as a subscripted variable.
*   only the arrays of same dimension can show arithematic operations

# Ndarray
N-Dimensional array(ndarray) in Numpy

Array in Numpy is a table of elements (usually numbers), all of the same type, indexed by a tuple of positive integers. In Numpy, number of dimensions of the array is called rank of the array.A tuple of integers giving the size of the array along each dimension is known as shape of the array. An array class in Numpy is called as ndarray. Elements in Numpy arrays are accessed by using square brackets and can be initialized by using nested Python Lists.
"""

l1=[223,12,4,0,43]
l2=[43,234,56]
l23=l1+l2
print(l23)

import numpy as np
array1=np.array([223,12,4,0,43])
array2=np.array([43,234,56])
array=array1+array2# array of 2 diff dimension can't add
print(array)

import numpy as np
array1=np.array([2,1,4])
array2=np.array([4,2,5])
arry=array1+array2
sub=array1-array2
prod=array1*array2
div=array1/array2
print(arry)
print(sub)
print(prod)
print(div)
print(array2**2)
print((array1*array2)**2)

print(arry)
print(array[2])

"""# SYS MODULE

---



---


The python sys module provides functions and variables which are used to manipulate different parts of the Python Runtime Environment. It lets us access system-specific parameters and functions.
"""



"""### why does list occupy more space in python

 a list is a mutable object, hence implying dynamic allocation of memory, so to avoid allocating space each time you append or modify the list (allocate enough space to contain the changed data and copy the data to it), it allocates additional space for future runtime changes, like appends and modifications.

 The point of an array is being able to compactly store smaller items. An array of bytes will be much, much smaller than a list of equivalent Python ints because a list can only contain 8-byte object references.

## Why do we prefer array as compared to list?

Since the array in Python is more compact and consumes less memory than a list, it is preferred to use an array when a large amount of data needs to be stored. 2. It is unnecessary to use a list to store the data when all elements are of the same data type and hence an array will be more efficient here.
"""

import numpy as np
import time
import sys
#creating list of 1000 elements
l=range(1000)
print(sys.getsizeof(l)*len(l))
#Creating numpy array of 1000 e,lements
array=np.arange(1000)
print(array.size*array.itemsize)

array=np.array([45,24,37,28])
start=time.time()
print(start)
list=[45,24,37,28]
start=time.time()
print(start)

import numpy as np
import time
import sys
size=10000
l1=range(size)
l2=range(size)
a1=np.arange(size)
a2=np.arange(size)
start=time.time()
result=[(x,y) for x,y in zip(l1,l2)]

print("time taken by list",(time.time()-start))

start=time.time()
result=a1+a2

print("The time taken by python numpy",(time.time()-start))

ray=np.array([[3,2],[21,45],[6,7]])
print(ray)
print(ray.itemsize)
print(ray.ndim)
print(ray.dtype)

array.ndim

array.itemsize

import numpy as np
array1=np.array([2,1,4])
array2=np.array([4,2,5])
arry=array1+array2
sub=array1-array2
prod=array1*array2
div=array1/array2
print(arry.dtype)
print(sub.dtype)
print(prod.dtype)
print(div.dtype)
print(div[1])

import numpy as np
array1=np.array([2,1,4])
array2=np.array([4,2,5])
div=array1/array2
print(div[1])

#using array to form matrix
array=np.array([[3,2,5],[21,45,3],[6,7,3]],dtype=np.float64)
array

array=np.array([[3,2,5],[21,45,3],[6,7,3]])
array.shape

array=np.array([[3,2,5],[21,45,3],[6,7,3]],dtype=np.complex)
array

a4=np.zeros((3,2))
a4

a4.ndim

a5=np.zeros(np.shape(a4))
a5

a3=np.ones((3,2))
a3

a6=np.ones(np.shape(a4))
a6

arr=np.arange(1,30,31)
arr

arr=np.arange(1,30,2)
arr

arr=np.arange(1,30,3)
arr.size

#linspace() function=="taking x numbers between two intervals(start,stop,no. of elements)"
np.linspace(1,6,3)

np.linspace(1,5,10)

ar=np.ones((3,3))
array=np.array([[3,2,5],[21,45,3],[6,7,3]])
sum=array+ar
print(sum)

# to get a transpose of a matrix
a34=np.array([[3,2,5,4],[21,45,32,78],[6,7,3,7]])
a22=a34.reshape(6,2)
print(a22)
print(" ")
print(np.ravel(a22))
print(" ")
print(a22)

"""ravel()
Python's ravel() function is used to return a contiguous array. This function returns a 1D array that contains the input elements
 ravel, which is used to change a 2-dimensional array or a multi-dimensional array into a contiguous flattened array. The returned array has the same data type as the source array or input array.
"""

import numpy as np
a11=np.array([[3,2,5],[2,4,3],[6,7,3]])
a12=np.array([[2,5,4],[7,3,7],[4,3,7]])
print(a11*a12)
print("")
a13=np.dot(a11,a12)
print(a13)

import numpy as np
a11=np.array([[3,2,5],[2,4,3],[6,7,3]])
a12=np.array([[2,5,4],[7,3,7],[4,3,7]])
result=np.zeros((3,3))
for i in range(len(a11)):
  for j in range (len(a12[0])):
    for k in range (len(a12)):
      result[i][j]+=a11[i][j]*a12[j][k]
for r in result:
  print(r)

li1=[[3,2,5],[2,4,3],[6,7,3]]
li2=[[2,5,4],[7,3,7],[4,3,7]]
result = [[0, 0, 0],[0, 0, 0],[0, 0, 0]]
for i in range(len(li1)):

    # iterating by column by B
    for j in range(len(li2[0])):
      for k in range(len(li2)):
        result[i][j] += li1[i][k] * li2[k][j]

for r in result:
    print(r)

import numpy as np

# create an array of sine values
a = np.array([0, np.pi/2, np.pi])
print ("Sine values of array elements:", np.sin(a))

# exponential values
a = np.array([0, 1, 2, 3])
print ("Exponent of array elements:", np.exp(a))

# square root of array values
print ("Square root of array elements:", np.sqrt(a))

a13.mean()

a13.max()

a13.median()

a13

a13.mode()

a11=np.array([[3,2,5],[2,4,3],[6,7,3]])
print(a11.sum(axis=0))#sum coloum wise
print(a11.sum(axis=1))#sum row wise
print(a11.max())
print(a11.min())
print(a11.size)
print(a11.ndim)
a2=np.sqrt(a11)
print(a2)

"""### **axis=0 sum coloum wise**
### axis=1 sum row wise
"""

a11=np.array([[3,2,5],[2,4,3],[6,7,3]])
a12=np.array([[2,5,4],[7,3,7],[4,3,7]])
a3=np.sqrt(a11)
a4=np.sqrt(a12)
print(a3)
print(" ")
print(a4)
a6=np.dot(a3,a4)
print(" ")
print(a6)

"""### INDEXING AND SLICING"""

class Queue:

  def __init__(self,a):
    self.a=[]
  def add(self,y):
    self.a.append(y)
  def show(self):
    print(self.a[0:2])
q=Queue(5)
q.add(3)
q.add(30)
q.add(6)

q.add(1)
q.show()

a11=np.array([[3,2,5,4],[2,4,3,6],[6,7,3,8],[2,3,5,6]])
a11[1:3,1]

a11[2:3]

a11[2:3,3]

a11[1:3,1:3]

a11[0:4,3]

a11[2:4,3]

a11[-1,-2]

a11[-1,-1]

a11[-1,-3:-1]

li=[]
a=input("Enter no ").split(" ")
li.append(a)
print(li)
li

for row in a11:
  print(row)

s= [row for row in a11]
print(s)

for row in a11:
  for item in row:
    print(item)

for cell in a11.flat:
  print(cell)

a19=np.array([[3,2,4],[4,3,6],[7,3,8]])
a20=a19.reshape(1,9)
for item in a20:
  print(item)

a19=np.array([[3,2,4],[4,3,6],[7,3,8]])
for a in a19:
  for j in a:
    print(j)
a19.ravel()

a=np.arange(100).reshape(4,25)
a

"""vstack() function is used to stack the sequence of NumPy arrays vertically and return the single array."""

a=np.array([[3,2,4],[4,3,6],[7,3,8]])
b=np.array([[3,2,4],[4,3,6],[7,3,8]])
c1=np.vstack((a,b))
c1

a=np.arange(20).reshape(4,5)
b=np.arange(20,40).reshape(4,5)
c1=np.vstack((a,b))
c1

a=np.arange(15).reshape(3,5)
b=np.arange(15,30).reshape(3,5)
c1=np.hstack((a,b))
c1

a11=np.array([[3,2,5,4],[2,2,3,4],[6,7,3,6],[2,7,5,6]])
count=0
m=int(input("Enter the first element"))
n=int(input("Enter the first element "))

a=np.arange(20).reshape(4,5)
b=a>4
print(type(b))
print(b)

a[b]=-1
a

"""The bincount() method of the NumPy module is used to find the frequency of each element in a NumPy array of positive integers. The element's index in the frequency array or bin is stored as the element's count. Because each bin value represents an instance of its index, we can adjust the bin size accordingly."""

x=np.array([3,2,5,4,2,2,3,4,6,7,3,6,2,7,5,6])
print("Original array: ")
print(x)
r=np.bincount(x)
print(r)

x=np.array([[3,2,5,4],[2,2,3,4],[6,7,3,6],[2,7,5,6]])
print("Original array: ")
print(x)
r=np.bincount(x)
print(r)

import numpy as np
arr = np.array([4, 4, 2, 1, 6, 8, 3, 3, 4, 15, 23])
freq_bin = np.bincount(arr)
print(freq_bin)

